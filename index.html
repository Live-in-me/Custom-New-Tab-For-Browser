<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>New Tab</title>
<style>
:root{
  --bg: #000;
  --text: rgba(255,255,255,0.92);

  /* Glass system */
  --glass: rgba(16,16,20,0.55);
  --glass2: rgba(16,16,20,0.46);
  --stroke: rgba(255,255,255,0.12);
  --stroke2: rgba(255,255,255,0.16);
  --shadow: 0 18px 60px rgba(0,0,0,0.60);

  /* Accent */
  --accent: #00ffff;
  --accentSoft: rgba(0,255,255,0.18);
}

*{ box-sizing:border-box; margin:0; padding:0; }

html, body{ height:100%; }

body{
  background: var(--bg);
  color: var(--text);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  overflow:hidden;
}

/* Background SVG */
.wave-bg{
  position:fixed;
  inset:0;
  width:100vw;
  height:100vh;
  z-index:-1;
  background: var(--bg);
}

/* Contours */
#contours path{
  fill:none;
  stroke-linecap:round;
  stroke-linejoin:round;
  transition: stroke 0.25s ease, stroke-width 0.25s ease, stroke-opacity 0.25s ease;
}

#contours path:hover{
  stroke: rgba(100,200,255,0.95);
  stroke-width: 2;
}

/* Clock */
/* Shared glass look */
:root{
  --glass: rgba(16,16,20,0.60);
  --stroke: rgba(255,255,255,0.14);
  --hi: rgba(255,255,255,0.10);
  --shadow: 0 18px 55px rgba(0,0,0,0.62);
  --accent: rgba(0,255,255,0.55);
  --accentRing: rgba(0,255,255,0.14);
}

/* CLOCK = pill, lighter presence */
.hero{
  position:absolute;
  left:50%;
  top:18vh;
  transform:translateX(-50%);
  width:min(760px, 92vw);

  padding: 18px 18px 16px;
  border-radius: 28px;

  background: rgba(16,16,20,0.52);
  border: 1px solid rgba(255,255,255,0.12);
  background-image: linear-gradient(to bottom, rgba(255,255,255,0.08), rgba(255,255,255,0.00));

  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  box-shadow: 0 26px 80px rgba(0,0,0,0.65);

  display:flex;
  flex-direction:column;
  gap: 16px;
  align-items:center;
}

.time{
  position:static;           
  transform:none;
  pointer-events:none;
  white-space:nowrap;

  font-size: clamp(76px, 12vw, 132px);
  font-weight: 560;
  letter-spacing: -1.6px;
  line-height: 1;

  color: rgba(255,255,255,0.92);
  text-shadow: 0 12px 30px rgba(0,0,0,0.55);

  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1;
}

.search-box{
  position:static;
  transform:none;
  margin-top: 20px;

  width: min(720px, 92%);
  padding: 18px 18px;

  border-radius: 18px;        /* smaller radius so it feels like a field */
  border: 1px solid rgba(255,255,255,0.6);

  background: rgba(0,0,0,0.22);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);

  color: rgba(255,255,255,0.92);
  font-size: 16px;
  font-weight: 560;
  letter-spacing: 0.2px;

  outline:none;
  text-align:left;
}

.search-box::placeholder{ color: rgba(255,255,255,0.55); }

.search-box:focus{
  border-color: rgba(0,255,255,0.55);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.06),
    0 0 0 3px rgba(0,255,255,0.12);
}




/* Dock (physics area + plate behind) */
#shortcuts{
  position:fixed;
  left:50%;
  bottom:16vh;
  transform:translateX(-50%);
  width:clamp(300px, 80vw, 1000px);
  height:140px;
  pointer-events:none;
  z-index:10;
}

/* Each chip carries its own “aura”, so nothing gets crossed */
.chip{
  position:absolute;
  width:65px; height:65px;
  border-radius:16px;

  display:grid;
  place-items:center;

  /* less boxy */
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.12);

  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);

  box-shadow:
    0 18px 45px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.08);

  pointer-events:auto;
  text-decoration:none;
  transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
}

.chip::before{
  content:"";
  position:absolute;
  inset:-22px;
  border-radius:22px;

  /* cleaner halo */
  background: radial-gradient(circle at 50% 70%,
    rgba(0,255,255,0.22),
    rgba(0,255,255,0.00) 62%);
  filter: blur(12px);
  opacity: 0.25;
  z-index:-1;
}

.chip img{
  width:35px; height:35px;
  filter: drop-shadow(0 10px 14px rgba(0,0,0,0.65));
  opacity: 0.95;
}

.chip:hover{
  border-color: rgba(0,255,255,0.55);
  box-shadow:
    0 26px 70px rgba(0,0,0,0.65),
    0 0 0 3px rgba(0,255,255,0.10),
    inset 0 1px 0 rgba(255,255,255,0.10);
}

.chip:hover::before{
  opacity: 0.55;
}

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce){
  #contours path{ transition:none; }
  .chip{ transition:none; }
  .search-box{ transition:none; }
}

</style>
</head>

<body>

<svg class="wave-bg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
  <g id="contours"></g>
</svg>
<div class="hero"> 
  <div class="time" id="timeLabel">--:--</div>
  <input
    type="text"
    class="search-box"
    placeholder="Hello there! Ready to explore the web?"
    id="search"
    autocapitalize="off"
    autocomplete="off"
    spellcheck="true"
  />
</div>


<div id="shortcuts">
  <a class="chip" href="https://github.com" target="_blank" rel="noopener">
    <img src="Github.png" alt="GitHub" loading="lazy" />
  </a>
  <a class="chip" href="https://youtube.com" target="_blank" rel="noopener">
    <img src="Youtube.png" alt="YouTube" loading="lazy" />
  </a>
  <a class="chip" href="https://mail.google.com" target="_blank" rel="noopener">
    <img src="Gmail.png" alt="Gmail" loading="lazy" />
  </a>
  <a class="chip" href="https://instagram.com" target="_blank" rel="noopener">
    <img src="Instagram.png" alt="Instagram" loading="lazy" />
  </a>
  <a class="chip" href="https://web.whatsapp.com" target="_blank" rel="noopener">
    <img src="Whatsapp.png" alt="WhatsApp" loading="lazy" />
  </a>
  <a class="chip" href="https://chatgpt.com" target="_blank" rel="noopener">
    <img src="ChatGPT.png" alt="ChatGPT" loading="lazy" />
  </a>
  <a class="chip" href="https://www.perplexity.ai" target="_blank" rel="noopener">
    <img src="Perplexity.png" alt="Perplexity" loading="lazy" />
  </a>
  <a class="chip" href="https://discord.com/channels/@me" target="_blank" rel="noopener">
    <img src="Discord.png" alt="Discord" loading="lazy" />
  </a>
</div>

<script>
/* TIME */
function updateTime(){
  const now = new Date();
  document.getElementById("timeLabel").textContent = now.toLocaleTimeString("en-US", {
    hour: "2-digit", minute: "2-digit", hour12: false
  });
}
setInterval(updateTime, 1000);
updateTime();

/* SEARCH */
const searchInput = document.getElementById("search");
searchInput.addEventListener("keydown", e => {
  if (e.key !== "Enter") return;
  const query = searchInput.value.trim();
  if (!query) return;

  const url = query.includes(".") && !query.includes(" ")
    ? (query.startsWith("http") ? query : "https://" + query)
    : "https://www.google.com/search?q=" + encodeURIComponent(query);

  window.location.href = url;
});

/* --- CONTOURS (marching squares + stitching) --- */
const contoursGroup = document.getElementById("contours");

/* Quality */
const GRID_W = 92;
const GRID_H = 62;

const ISO_LEVELS = 18;     // fewer lines like the screenshot
const ISO_CENTER = 0.09;   // where contours cluster
const ISO_STEP = 0.3;     // spacing knob (~0.6cm-ish feel on many screens)

/* Stroke look */
const STROKE_W = 3;
const STROKE_ALPHA = 0.95; // applied via stroke-opacity (safer than rgba) [web:0]

/* Calm motion */
const SPEED_NORMAL = 0.20;
const SPEED_TYPING = 0.30;
const TYPING_DECAY_MS = 700;
const SPEED_SMOOTHING = 9;

let seed = Math.random() * 1000;
let tAcc = 0;

let speedCurrent = SPEED_NORMAL;
let speedTarget  = SPEED_NORMAL;
let typingTimer = null;

// Smooth speed changes
function smoothToTarget(current, target, dt, smoothing){
  const alpha = 1 - Math.exp(-smoothing * dt);
  return current + (target - current) * alpha;
}

/* Field tuned to create “topo islands” */
function field(x, y, t, s){
  const nx = x / (GRID_W - 1);
  const ny = y / (GRID_H - 1);

  const ox = 0.18 * Math.sin(t * 0.35 + s * 0.13);
  const oy = 0.16 * Math.cos(t * 0.30 + s * 0.17);

  const w1 = Math.sin((nx + ox) * 7.0 + t * 0.55) * 0.55;
  const w2 = Math.sin((ny + oy) * 8.0 - t * 0.50) * 0.48;
  const w3 = Math.sin((nx * 5.2 + ny * 4.4) + t * 0.40) * 0.40;
  const w4 = Math.sin((nx * 10.0 - ny * 9.0) - t * 0.25) * 0.28;

  const cx = 0.5 + 0.16 * Math.sin(t * 0.16 + s * 0.27);
  const cy = 0.5 + 0.14 * Math.cos(t * 0.14 + s * 0.21);
  const dx = (nx - cx) * 1.15;
  const dy = (ny - cy) * 1.15;
  const blob = Math.exp(-(dx*dx + dy*dy) * 2.2) * 1.0;

  return w1 + w2 + w3 + w4 + blob;
}

function interp(x1, y1, v1, x2, y2, v2, iso){
  const tt = (iso - v1) / (v2 - v1);
  return { x: x1 + (x2 - x1) * tt, y: y1 + (y2 - y1) * tt };
}

function marchingSquares(grid, iso){
  const segs = [];
  for (let y = 0; y < GRID_H - 1; y++){
    for (let x = 0; x < GRID_W - 1; x++){
      const vTL = grid[y][x];
      const vTR = grid[y][x+1];
      const vBR = grid[y+1][x+1];
      const vBL = grid[y+1][x];

      let c = 0;
      if (vTL >= iso) c |= 8;
      if (vTR >= iso) c |= 4;
      if (vBR >= iso) c |= 2;
      if (vBL >= iso) c |= 1;

      if (c === 0 || c === 15) continue;

      const x0 = x, x1 = x + 1, y0 = y, y1 = y + 1;
      const ptTop    = interp(x0, y0, vTL, x1, y0, vTR, iso);
      const ptRight  = interp(x1, y0, vTR, x1, y1, vBR, iso);
      const ptBottom = interp(x0, y1, vBL, x1, y1, vBR, iso);
      const ptLeft   = interp(x0, y0, vTL, x0, y1, vBL, iso);

      switch (c){
        case 1:  segs.push([ptLeft, ptBottom]); break;
        case 2:  segs.push([ptBottom, ptRight]); break;
        case 3:  segs.push([ptLeft, ptRight]); break;
        case 4:  segs.push([ptTop, ptRight]); break;
        case 5:  segs.push([ptTop, ptLeft]); segs.push([ptBottom, ptRight]); break;
        case 6:  segs.push([ptTop, ptBottom]); break;
        case 7:  segs.push([ptTop, ptLeft]); break;
        case 8:  segs.push([ptTop, ptLeft]); break;
        case 9:  segs.push([ptTop, ptBottom]); break;
        case 10: segs.push([ptTop, ptRight]); segs.push([ptLeft, ptBottom]); break;
        case 11: segs.push([ptTop, ptRight]); break;
        case 12: segs.push([ptLeft, ptRight]); break;
        case 13: segs.push([ptBottom, ptRight]); break;
        case 14: segs.push([ptLeft, ptBottom]); break;
      }
    }
  }
  return segs;
}

/* Stitching */
const EPS = 0.9; // pixel tolerance after scaling
function qkey(p){
  const x = Math.round(p.x / EPS);
  const y = Math.round(p.y / EPS);
  return x + "," + y;
}

function stitchSegments(segments){
  const buckets = new Map();
  const used = new Array(segments.length).fill(false);

  function addEndpoint(key, segIndex, endIndex){
    if (!buckets.has(key)) buckets.set(key, []);
    buckets.get(key).push([segIndex, endIndex]);
  }

  segments.forEach((seg, i) => {
    addEndpoint(qkey(seg[0]), i, 0);
    addEndpoint(qkey(seg[1]), i, 1);
  });

  function takeNext(key, currentSegIndex){
    const list = buckets.get(key);
    if (!list) return null;

    for (const [si, ei] of list){
      if (used[si]) continue;
      if (si === currentSegIndex) continue;
      return [si, ei];
    }
    for (const [si, ei] of list){
      if (used[si]) continue;
      return [si, ei];
    }
    return null;
  }

  const polylines = [];

  for (let i = 0; i < segments.length; i++){
    if (used[i]) continue;

    used[i] = true;
    const line = [segments[i][0], segments[i][1]];

    // forward
    let currentSeg = i;
    let end = line[line.length - 1];
    while (true){
      const next = takeNext(qkey(end), currentSeg);
      if (!next) break;

      const [ni, endIndex] = next;
      used[ni] = true;

      const seg = segments[ni];
      const other = seg[1 - endIndex];
      line.push(other);

      currentSeg = ni;
      end = other;
    }

    // backward
    currentSeg = i;
    let start = line[0];
    while (true){
      const next = takeNext(qkey(start), currentSeg);
      if (!next) break;

      const [ni, endIndex] = next;
      used[ni] = true;

      const seg = segments[ni];
      const other = seg[1 - endIndex];
      line.unshift(other);

      currentSeg = ni;
      start = other;
    }

    polylines.push(line);
  }

  return polylines;
}

function polylineToPathD(points, closeIfLoop = true){
  if (!points || points.length < 2) return "";
  let d = `M ${points[0].x} ${points[0].y}`;
  for (let i = 1; i < points.length; i++){
    d += ` L ${points[i].x} ${points[i].y}`;
  }
  if (closeIfLoop){
    const first = points[0];
    const last = points[points.length - 1];
    if (Math.hypot(first.x - last.x, first.y - last.y) < EPS * 1.5) d += " Z";
  }
  return d;
}

function generateContourPaths(){
  contoursGroup.innerHTML = "";

  // Weighted thickness: mostly thin, some medium, few thick (still 1..3)
  function weightedStrokeWidth(){
    const r = Math.random();
    // 70% thin: 1.00 - 1.55
    if (r < 0.70) return (1.00 + Math.random() * 0.55).toFixed(2);
    // 25% medium: 1.55 - 2.30
    if (r < 0.95) return (1.55 + Math.random() * 0.75).toFixed(2);
    // 5% thick: 2.30 - 3.00
    return (2.30 + Math.random() * 0.70).toFixed(2);
  }

  for (let i = 0; i < ISO_LEVELS; i++){
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");

    // Some pure white, some greys
    const rr = Math.random();
    let brightness;
    if (rr < 0.22) brightness = 255;       // pure white
    else if (rr < 0.72) brightness = 220;  // light grey
    else brightness = 175;                 // darker grey

    path.setAttribute("stroke", `rgb(${brightness},${brightness},${brightness})`);
    path.setAttribute("stroke-opacity", String(STROKE_ALPHA));
    path.setAttribute("stroke-width", weightedStrokeWidth()); // <- weighted 1..3
    path.setAttribute("fill", "none");

    contoursGroup.appendChild(path);
  }
}


function renderContours(t){
  const grid = Array.from({length: GRID_H}, (_, y) =>
    Array.from({length: GRID_W}, (_, x) => field(x, y, t, seed))
  );

  const sx = 1200 / (GRID_W - 1);
  const sy = 800 / (GRID_H - 1);

  const paths = contoursGroup.querySelectorAll("path");
  const mid = (ISO_LEVELS - 1) / 2;

  paths.forEach((path, idx) => {
    // ISO_STEP controls spacing between lines
    const iso = ISO_CENTER + (idx - mid) * ISO_STEP;

    const segs = marchingSquares(grid, iso);
    const scaledSegs = segs.map(([p0, p1]) => ([
      { x: p0.x * sx, y: p0.y * sy },
      { x: p1.x * sx, y: p1.y * sy }
    ]));

    const polylines = stitchSegments(scaledSegs);

    let d = "";
    for (const line of polylines){
      if (line.length < 3) continue;
      d += polylineToPathD(line, true) + " ";
    }
    path.setAttribute("d", d.trim());
  });
}

function bumpSpeed(){
  speedTarget = SPEED_TYPING;
  clearTimeout(typingTimer);
  typingTimer = setTimeout(() => speedTarget = SPEED_NORMAL, TYPING_DECAY_MS);
}
searchInput.addEventListener("input", bumpSpeed);

window.addEventListener("click", () => { seed = Math.random() * 1000; });

let lastT = performance.now();
function frame(now){
  const dt = Math.min(0.05, (now - lastT) / 1000);
  lastT = now;

  speedCurrent = smoothToTarget(speedCurrent, speedTarget, dt, SPEED_SMOOTHING);
  tAcc += dt * speedCurrent;

  renderContours(tAcc);
  requestAnimationFrame(frame);
}

window.addEventListener("load", () => {
  generateContourPaths();
  requestAnimationFrame(frame);
});

/* --- CHIP PHYSICS (unchanged) --- */
function initChips(){
  const container = document.getElementById("shortcuts");
  const chips = Array.from(container.querySelectorAll(".chip"));
  if (!chips.length) return;

  // Chip dimensions from CSS
  const chipSize = 65;
  const desiredGap = 20; // space between chip edges (px)
  
  // Calculate total width and centering
  const totalNeeded = chips.length * chipSize + (chips.length - 1) * desiredGap;
  const availableWidth = container.clientWidth;
  const startX = (availableWidth - totalNeeded) / 2 + chipSize / 2;

  const state = chips.map((chip, i) => {
    const rect = chip.getBoundingClientRect();
    return {
      el: chip,
      x: startX + i * (chipSize + desiredGap),
      y: container.clientHeight * 0.5,
      vx: 0, // start with zero velocity (no initial chaos)
      vy: 0,
      r: Math.max(rect.width, rect.height) * 0.5,
      wobble: Math.random() * Math.PI * 2
    };
  });

  // Apply initial positions BEFORE starting animation loop
  state.forEach(s => {
    s.el.style.transform = `translate3d(${s.x - s.r}px, ${s.y - s.r}px, 0)`;
  });

  const config = {
    margin: 16,
    damping: 0.965,
    noise: 0.012,
    snapBack: 0.010,
    maxSpeed: 3.2,
    typeKick: { vx: 1.5, vy: 0.8 }
  };

  const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

  function updateChipPositions(){
    state.forEach(s => {
      s.wobble += 0.03;
      const wobbleX = Math.sin(s.wobble) * 4;
      const wobbleY = Math.cos(s.wobble * 1.1) * 2;

      s.vx += (Math.random() - 0.5) * config.noise;
      s.vy += (Math.random() - 0.5) * config.noise;

      s.vy += (container.clientHeight * 0.60 - s.y) * config.snapBack;

      s.vx = clamp(s.vx, -config.maxSpeed, config.maxSpeed);
      s.vy = clamp(s.vy, -config.maxSpeed, config.maxSpeed);

      s.x += s.vx + wobbleX * 0.03;
      s.y += s.vy + wobbleY * 0.03;

      const left = config.margin + s.r;
      const right = container.clientWidth - config.margin - s.r;
      const top = config.margin + s.r;
      const bottom = container.clientHeight - config.margin - s.r;

      if (s.x < left){ s.x = left; s.vx *= -1; }
      if (s.x > right){ s.x = right; s.vx *= -1; }
      if (s.y < top){ s.y = top; s.vy *= -1; }
      if (s.y > bottom){ s.y = bottom; s.vy *= -1; }

      s.vx *= config.damping;
      s.vy *= config.damping;
    });

    // Collision detection
    for (let i = 0; i < state.length; i++){
      for (let j = i + 1; j < state.length; j++){
        const a = state[i], b = state[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        const minDist = a.r + b.r;

        if (dist < minDist && dist > 0){
          const overlap = (minDist - dist) * 0.5;
          const nx = dx / dist;
          const ny = dy / dist;
          a.x -= nx * overlap; a.y -= ny* overlap;
          b.x += nx * overlap; b.y += ny * overlap;
        }
      }
    }

    state.forEach(s => {
      s.el.style.transform = `translate3d(${s.x - s.r}px, ${s.y - s.r}px, 0)`;
    });

    requestAnimationFrame(updateChipPositions);
  }

  function applyImpulse(strength = 1){
    const baseAngle = Math.random() * Math.PI * 2;
    state.forEach((s, i) => {
      const angle = baseAngle + i * 0.6;
      s.vx += Math.cos(angle) * config.typeKick.vx * strength;
      s.vy += Math.sin(angle) * config.typeKick.vy * strength;
    });
  }

  searchInput.addEventListener("input", () => applyImpulse(1));
  searchInput.addEventListener("keydown", e => {
    if (/[a-z0-9]/i.test(e.key) || e.key === "Backspace") applyImpulse(0.6);
  });

  // Start animation loop AFTER initial positioning
  requestAnimationFrame(updateChipPositions);
}
initChips();

</script>

</body>
</html>