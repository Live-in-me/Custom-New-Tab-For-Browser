<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="icon" type="image/png"  href="Icons.png" />
<title>New Tab</title>

<style>
:root{
  --bg: #000;
  --text: rgba(255,255,255,0.92);

  --glass: rgba(16,16,20,0.58);
  --glass2: rgba(16,16,20,0.46);
  --stroke: rgba(255,255,255,0.12);
  --stroke2: rgba(255,255,255,0.18);
  --hi: rgba(255,255,255,0.10);
  --shadow: 0 20px 70px rgba(0,0,0,0.65);

  --accent: #00ffff;
  --accentSoft: rgba(0,255,255,0.16);
  --accentRing: rgba(0,255,255,0.12);
}

*{ box-sizing:border-box; margin:0; padding:0; }
html, body{ height:100%; }

body{
  background: var(--bg);
  color: var(--text);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  overflow:hidden;
}

.wave-bg{
  position:fixed;
  inset:0;
  width:100vw;
  height:100vh;
  z-index:-2;
  background: var(--bg);
}

body::after{
  content:"";
  position:fixed;
  inset:0;
  z-index:-1;
  pointer-events:none;
  opacity:0.14;
  mix-blend-mode: overlay;
  background-image:
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.45'/%3E%3C/svg%3E");
}

#contours path{
  fill:none;
  stroke-linecap:round;
  stroke-linejoin:round;
  transition: stroke 0.25s ease, stroke-width 0.25s ease, stroke-opacity 0.25s ease;
}

#contours path:hover{
  stroke: rgba(100,200,255,0.95);
  stroke-width: 2;
}

.hero{
  position:absolute;
  left:50%;
  top:18vh;
  transform:translateX(-50%);
  width:min(780px, 92vw);

  padding: 20px 20px 18px;
  border-radius: 30px;

  background: linear-gradient(
    to bottom,
    rgba(255,255,255,0.10),
    rgba(255,255,255,0.03)
  );
  border: 1px solid var(--stroke);
  backdrop-filter: blur(22px);
  -webkit-backdrop-filter: blur(22px);

  box-shadow: var(--shadow);
  overflow:hidden;

  display:flex;
  flex-direction:column;
  gap: 16px;
  align-items:center;
}

.hero::before{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  border-radius: inherit;
  background:
    radial-gradient(circle at 20% 10%, rgba(0,255,255,0.12), transparent 55%),
    radial-gradient(circle at 80% 0%, rgba(255,255,255,0.10), transparent 50%);
  opacity:0.9;
}

.time{
  position:relative;
  z-index:2;
  pointer-events:none;
  white-space:nowrap;

  font-size: clamp(76px, 12vw, 138px);
  font-weight: 600;
  letter-spacing: -1.8px;
  line-height: 1;

  color: rgba(255,255,255,0.93);
  text-shadow:
    0 14px 35px rgba(0,0,0,0.58),
    0 0 28px rgba(0,255,255,0.06);

  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1;
}

.search-row{
  position:relative;
  z-index:2;
  width:min(720px, 92%);
}

.search-box{
  width:100%;
  padding: 18px 62px 18px 18px;

  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.22);

  background: rgba(0,0,0,0.28);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.08),
    0 10px 30px rgba(0,0,0,0.35);

  color: rgba(255,255,255,0.92);
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 0.2px;

  outline:none;
  text-align:left;

  transition: border-color 160ms ease, box-shadow 160ms ease, transform 160ms ease;
}

.search-box::placeholder{ color: rgba(255,255,255,0.55); }
.search-box:focus{
  border-color: rgba(0,255,255,0.55);
  transform: translateY(-1px);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.08),
    0 0 0 3px rgba(0,255,255,0.10),
    0 16px 40px rgba(0,0,0,0.45);
}

.image-search-btn{
  position:absolute;
  right:12px;
  top:50%;
  transform:translateY(-50%);
  width:36px;
  height:36px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.22);
  background: rgba(255,255,255,0.08);
  display:grid;
  place-items:center;
  cursor:pointer;
  transition: border-color 160ms ease, background-color 160ms ease;
}

.image-search-btn:hover{
  border-color: rgba(0,255,255,0.55);
  background: rgba(0,255,255,0.14);
}

.image-search-btn img{
  width:20px;
  height:20px;
}

#shortcuts{
  position:fixed;
  left:50%;
  bottom:16vh;
  transform:translateX(-50%);
  width:clamp(320px, 82vw, 1020px);
  height:150px;
  pointer-events:none;
  z-index:10;
}

.chip{
  position:absolute;
  width:65px; height:65px;
  border-radius:18px;

  display:grid;
  place-items:center;

  background: linear-gradient(
    to bottom,
    rgba(255,255,255,0.08),
    rgba(255,255,255,0.02)
  );
  border: 1px solid rgba(255,255,255,0.14);

  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  box-shadow:
    0 18px 55px rgba(0,0,0,0.58),
    inset 0 1px 0 rgba(255,255,255,0.10);

  pointer-events:auto;
  text-decoration:none;
  transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
}

.chip::before{
  content:"";
  position:absolute;
  inset:-24px;
  border-radius:24px;

  background: radial-gradient(circle at 50% 70%,
    rgba(0,255,255,0.20),
    rgba(0,255,255,0.00) 65%);
  filter: blur(13px);
  opacity: 0.22;
  z-index:-1;
  transition: opacity 160ms ease;
}

.chip img{
  width:36px; height:36px;
  filter: drop-shadow(0 12px 16px rgba(0,0,0,0.70));
  opacity: 0.96;
}

.chip:hover{
  border-color: rgba(0,255,255,0.55);
  box-shadow:
    0 26px 80px rgba(0,0,0,0.68),
    0 0 0 3px rgba(0,255,255,0.10),
    inset 0 1px 0 rgba(255,255,255,0.12);
  transform: translateY(-3px) scale(1.02);
}

.chip:hover::before{
  opacity: 0.60;
}

@media (prefers-reduced-motion: reduce){
  #contours path{ transition:none; }
  .chip{ transition:none; }
  .search-box{ transition:none; }
}

@media (max-height: 700px){
  .hero{ top: 12vh; }
  #shortcuts{ bottom: 10vh; }
}
</style>
</head>

<body>

<svg class="wave-bg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
  <g id="contours"></g>
</svg>

<div class="hero">
  <div class="time" id="timeLabel">--:--</div>
  <div class="search-row">
    <input
      type="text"
      class="search-box"
      placeholder="Hello there! Ready to explore the web?"
      id="search"
      autocapitalize="off"
      autocomplete="off"
      spellcheck="true"
    />
    <button type="button" class="image-search-btn" id="imageSearchBtn" aria-label="Image search">
      <img src="Lens.png" alt="Image search" loading="lazy" />
    </button>
  </div>
</div>

<div id="shortcuts">
  <a class="chip" href="https://github.com" target="_blank" rel="noopener">
    <img src="Github.png" alt="GitHub" loading="lazy" />
  </a>
  <a class="chip" href="https://youtube.com" target="_blank" rel="noopener">
    <img src="Youtube.png" alt="YouTube" loading="lazy" />
  </a>
  <a class="chip" href="https://mail.google.com" target="_blank" rel="noopener">
    <img src="Gmail.png" alt="Gmail" loading="lazy" />
  </a>
  <a class="chip" href="https://instagram.com" target="_blank" rel="noopener">
    <img src="Instagram.png" alt="Instagram" loading="lazy" />
  </a>
  <a class="chip" href="https://web.whatsapp.com" target="_blank" rel="noopener">
    <img src="Whatsapp.png" alt="WhatsApp" loading="lazy" />
  </a>
  <a class="chip" href="https://chatgpt.com" target="_blank" rel="noopener">
    <img src="ChatGPT.png" alt="ChatGPT" loading="lazy" />
  </a>
  <a class="chip" href="https://discord.com/channels/@me" target="_blank" rel="noopener">
    <img src="Discord.png" alt="Discord" loading="lazy" />
  </a>
  <a class="chip" href="https://console.firebase.google.com/u/1/" target="_blank" rel="noopener">
    <img src="Firebase.png" alt="Firebase" loading="lazy" />
  </a>
</div>

<script>
function updateTime() {
  const now = new Date();
  document.getElementById('timeLabel').textContent = now.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  });
}
setInterval(updateTime, 1000);
updateTime();

const searchInput = document.getElementById('search');
const imageSearchBtn = document.getElementById('imageSearchBtn');

function getWebSearchUrl(query) {
  return query.includes('.') && !query.includes(' ')
    ? (query.startsWith('http') ? query : 'https://' + query)
    : 'https://www.google.com/search?q=' + encodeURIComponent(query);
}

function getImageSearchUrl(query) {
  return query
    ? 'https://www.google.com/search?tbm=isch&q=' + encodeURIComponent(query)
    : 'https://images.google.com/';
}

searchInput.addEventListener('keydown', e => {
  if (e.key !== 'Enter') return;
  const query = searchInput.value.trim();
  if (!query) return;
  window.location.href = getWebSearchUrl(query);
});

imageSearchBtn.addEventListener('click', () => {
  const query = searchInput.value.trim();
  window.location.href = getImageSearchUrl(query);
});

const contoursGroup = document.getElementById('contours');

const GRID_W = 92;
const GRID_H = 62;
const ISO_LEVELS = 18;
const ISO_CENTER = 0.09;
const ISO_STEP = 0.3;

const STROKE_ALPHA = 0.95;

const SPEED_NORMAL = 0.2;
const SPEED_TYPING = 0.3;
const TYPING_DECAY_MS = 700;
const SPEED_SMOOTHING = 9;

let seed = Math.random() * 1000;
let tAcc = 0;
let speedCurrent = SPEED_NORMAL;
let speedTarget = SPEED_NORMAL;
let typingTimer = null;

function smoothToTarget(current, target, dt, smoothing) {
  const alpha = 1 - Math.exp(-smoothing * dt);
  return current + (target - current) * alpha;
}

function field(x, y, t, s) {
  const nx = x / (GRID_W - 1);
  const ny = y / (GRID_H - 1);

  const ox = 0.18 * Math.sin(t * 0.35 + s * 0.13);
  const oy = 0.16 * Math.cos(t * 0.3 + s * 0.17);

  const w1 = Math.sin((nx + ox) * 7 + t * 0.55) * 0.55;
  const w2 = Math.sin((ny + oy) * 8 - t * 0.5) * 0.48;
  const w3 = Math.sin((nx * 5.2 + ny * 4.4) + t * 0.4) * 0.4;
  const w4 = Math.sin((nx * 10 - ny * 9) - t * 0.25) * 0.28;

  const cx = 0.5 + 0.16 * Math.sin(t * 0.16 + s * 0.27);
  const cy = 0.5 + 0.14 * Math.cos(t * 0.14 + s * 0.21);
  const dx = (nx - cx) * 1.15;
  const dy = (ny - cy) * 1.15;
  const blob = Math.exp(-(dx * dx + dy * dy) * 2.2) * 1;

  return w1 + w2 + w3 + w4 + blob;
}

function interp(x1, y1, v1, x2, y2, v2, iso) {
  const tt = (iso - v1) / (v2 - v1);
  return { x: x1 + (x2 - x1) * tt, y: y1 + (y2 - y1) * tt };
}

function marchingSquares(grid, iso) {
  const segs = [];
  for (let y = 0; y < GRID_H - 1; y++) {
    for (let x = 0; x < GRID_W - 1; x++) {
      const vTL = grid[y][x];
      const vTR = grid[y][x + 1];
      const vBR = grid[y + 1][x + 1];
      const vBL = grid[y + 1][x];

      let c = 0;
      if (vTL >= iso) c |= 8;
      if (vTR >= iso) c |= 4;
      if (vBR >= iso) c |= 2;
      if (vBL >= iso) c |= 1;
      if (c === 0 || c === 15) continue;

      const x0 = x, x1 = x + 1, y0 = y, y1 = y + 1;

      const ptTop = interp(x0, y0, vTL, x1, y0, vTR, iso);
      const ptRight = interp(x1, y0, vTR, x1, y1, vBR, iso);
      const ptBottom = interp(x0, y1, vBL, x1, y1, vBR, iso);
      const ptLeft = interp(x0, y0, vTL, x0, y1, vBL, iso);

      switch (c) {
        case 1: segs.push([ptLeft, ptBottom]); break;
        case 2: segs.push([ptBottom, ptRight]); break;
        case 3: segs.push([ptLeft, ptRight]); break;
        case 4: segs.push([ptTop, ptRight]); break;
        case 5: segs.push([ptTop, ptLeft]); segs.push([ptBottom, ptRight]); break;
        case 6: segs.push([ptTop, ptBottom]); break;
        case 7: segs.push([ptTop, ptLeft]); break;
        case 8: segs.push([ptTop, ptLeft]); break;
        case 9: segs.push([ptTop, ptBottom]); break;
        case 10: segs.push([ptTop, ptRight]); segs.push([ptLeft, ptBottom]); break;
        case 11: segs.push([ptTop, ptRight]); break;
        case 12: segs.push([ptLeft, ptRight]); break;
        case 13: segs.push([ptBottom, ptRight]); break;
        case 14: segs.push([ptLeft, ptBottom]); break;
      }
    }
  }
  return segs;
}

const EPS = 0.9;
function qkey(p) {
  const x = Math.round(p.x / EPS);
  const y = Math.round(p.y / EPS);
  return x + ',' + y;
}

function stitchSegments(segments) {
  const buckets = new Map();
  const used = new Array(segments.length).fill(false);

  function addEndpoint(key, segIndex, endIndex) {
    if (!buckets.has(key)) buckets.set(key, []);
    buckets.get(key).push([segIndex, endIndex]);
  }

  segments.forEach((seg, i) => {
    addEndpoint(qkey(seg[0]), i, 0);
    addEndpoint(qkey(seg[1]), i, 1);
  });

  function takeNext(key, currentSegIndex) {
    const list = buckets.get(key);
    if (!list) return null;
    for (const [si, ei] of list) {
      if (used[si]) continue;
      if (si === currentSegIndex) continue;
      return [si, ei];
    }
    for (const [si, ei] of list) {
      if (used[si]) continue;
      return [si, ei];
    }
    return null;
  }

  const polylines = [];
  for (let i = 0; i < segments.length; i++) {
    if (used[i]) continue;
    used[i] = true;

    const line = [segments[i][0], segments[i][1]];

    let currentSeg = i;
    let end = line[line.length - 1];
    while (true) {
      const next = takeNext(qkey(end), currentSeg);
      if (!next) break;
      const [ni, endIndex] = next;
      used[ni] = true;
      const seg = segments[ni];
      const other = seg[1 - endIndex];
      line.push(other);
      currentSeg = ni;
      end = other;
    }

    currentSeg = i;
    let start = line[0];
    while (true) {
      const next = takeNext(qkey(start), currentSeg);
      if (!next) break;
      const [ni, endIndex] = next;
      used[ni] = true;
      const seg = segments[ni];
      const other = seg[1 - endIndex];
      line.unshift(other);
      currentSeg = ni;
      start = other;
    }

    polylines.push(line);
  }

  return polylines;
}

function polylineToPathD(points, closeIfLoop = true) {
  if (!points || points.length < 2) return '';
  let d = `M ${points[0].x} ${points[0].y}`;
  for (let i = 1; i < points.length; i++) d += ` L ${points[i].x} ${points[i].y}`;

  if (closeIfLoop) {
    const first = points[0];
    const last = points[points.length - 1];
    if (Math.hypot(first.x - last.x, first.y - last.y) < EPS * 1.5) d += ' Z';
  }
  return d;
}

function generateContourPaths() {
  contoursGroup.innerHTML = '';

  function weightedStrokeWidth() {
    const r = Math.random();
    if (r < 0.7) return (1 + Math.random() * 0.55).toFixed(2);
    if (r < 0.95) return (1.55 + Math.random() * 0.75).toFixed(2);
    return (2.3 + Math.random() * 0.7).toFixed(2);
  }

  for (let i = 0; i < ISO_LEVELS; i++) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const rr = Math.random();
    let brightness;
    if (rr < 0.22) brightness = 255;
    else if (rr < 0.72) brightness = 220;
    else brightness = 175;

    path.setAttribute('stroke', `rgb(${brightness},${brightness},${brightness})`);
    path.setAttribute('stroke-opacity', String(STROKE_ALPHA));
    path.setAttribute('stroke-width', weightedStrokeWidth());
    path.setAttribute('fill', 'none');
    contoursGroup.appendChild(path);
  }
}

function renderContours(t) {
  const grid = Array.from({ length: GRID_H }, (_, y) =>
    Array.from({ length: GRID_W }, (_, x) => field(x, y, t, seed))
  );

  const sx = 1200 / (GRID_W - 1);
  const sy = 800 / (GRID_H - 1);
  const paths = contoursGroup.querySelectorAll('path');
  const mid = (ISO_LEVELS - 1) / 2;

  paths.forEach((path, idx) => {
    const iso = ISO_CENTER + (idx - mid) * ISO_STEP;
    const segs = marchingSquares(grid, iso);

    const scaledSegs = segs.map(([p0, p1]) => ([
      { x: p0.x * sx, y: p0.y * sy },
      { x: p1.x * sx, y: p1.y * sy }
    ]));

    const polylines = stitchSegments(scaledSegs);

    let d = '';
    for (const line of polylines) {
      if (line.length < 3) continue;
      d += polylineToPathD(line, true) + ' ';
    }
    path.setAttribute('d', d.trim());
  });
}

function bumpSpeed() {
  speedTarget = SPEED_TYPING;
  clearTimeout(typingTimer);
  typingTimer = setTimeout(() => speedTarget = SPEED_NORMAL, TYPING_DECAY_MS);
}

searchInput.addEventListener('input', bumpSpeed);

let lastT = performance.now();
function frame(now) {
  const dt = Math.min(0.05, (now - lastT) / 1000);
  lastT = now;
  speedCurrent = smoothToTarget(speedCurrent, speedTarget, dt, SPEED_SMOOTHING);
  tAcc += dt * speedCurrent;
  renderContours(tAcc);
  requestAnimationFrame(frame);
}

window.addEventListener('load', () => {
  generateContourPaths();
  requestAnimationFrame(frame);
});

function initChips() {
  const container = document.getElementById('shortcuts');
  const chips = Array.from(container.querySelectorAll('.chip'));
  if (!chips.length) return;

  const chipSize = 65;
  const desiredGap = 20;
  const totalNeeded = chips.length * chipSize + (chips.length - 1) * desiredGap;
  const availableWidth = container.clientWidth;
  const startX = (availableWidth - totalNeeded) / 2 + chipSize / 2;

  const state = chips.map((chip, i) => {
    const rect = chip.getBoundingClientRect();
    return {
      el: chip,
      x: startX + i * (chipSize + desiredGap),
      y: container.clientHeight * 0.5,
      vx: 0,
      vy: 0,
      r: Math.max(rect.width, rect.height) * 0.5,
      wobble: Math.random() * Math.PI * 2
    };
  });

  state.forEach(s => {
    s.el.style.transform = `translate3d(${s.x - s.r}px, ${s.y - s.r}px, 0)`;
  });

  const config = {
    margin: 16,
    damping: 0.965,
    noise: 0.012,
    snapBack: 0.01,
    maxSpeed: 3.2,
    typeKick: { vx: 1.5, vy: 0.8 }
  };

  const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

  function updateChipPositions() {
    state.forEach(s => {
      s.wobble += 0.03;

      const wobbleX = Math.sin(s.wobble) * 4;
      const wobbleY = Math.cos(s.wobble * 1.1) * 2;

      s.vx += (Math.random() - 0.5) * config.noise;
      s.vy += (Math.random() - 0.5) * config.noise;
      s.vy += (container.clientHeight * 0.6 - s.y) * config.snapBack;

      s.vx = clamp(s.vx, -config.maxSpeed, config.maxSpeed);
      s.vy = clamp(s.vy, -config.maxSpeed, config.maxSpeed);

      s.x += s.vx + wobbleX * 0.03;
      s.y += s.vy + wobbleY * 0.03;

      const left = config.margin + s.r;
      const right = container.clientWidth - config.margin - s.r;
      const top = config.margin + s.r;
      const bottom = container.clientHeight - config.margin - s.r;

      if (s.x < left) { s.x = left; s.vx *= -1; }
      if (s.x > right) { s.x = right; s.vx *= -1; }
      if (s.y < top) { s.y = top; s.vy *= -1; }
      if (s.y > bottom) { s.y = bottom; s.vy *= -1; }

      s.vx *= config.damping;
      s.vy *= config.damping;
    });

    for (let i = 0; i < state.length; i++) {
      for (let j = i + 1; j < state.length; j++) {
        const a = state[i], b = state[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        const minDist = a.r + b.r;
        if (dist < minDist && dist > 0) {
          const overlap = (minDist - dist) * 0.5;
          const nx = dx / dist;
          const ny = dy / dist;
          a.x -= nx * overlap; a.y -= ny * overlap;
          b.x += nx * overlap; b.y += ny * overlap;
        }
      }
    }

    state.forEach(s => {
      s.el.style.transform = `translate3d(${s.x - s.r}px, ${s.y - s.r}px, 0)`;
    });

    requestAnimationFrame(updateChipPositions);
  }

  function applyImpulse(strength = 1) {
    const baseAngle = Math.random() * Math.PI * 2;
    state.forEach((s, i) => {
      const angle = baseAngle + i * 0.6;
      s.vx += Math.cos(angle) * config.typeKick.vx * strength;
      s.vy += Math.sin(angle) * config.typeKick.vy * strength;
    });
  }

  searchInput.addEventListener('input', () => applyImpulse(1));
  searchInput.addEventListener('keydown', e => {
    if (/[a-z0-9]/i.test(e.key) || e.key === 'Backspace') applyImpulse(0.6);
  });

  requestAnimationFrame(updateChipPositions);
}
initChips();
</script>

</body>
</html>
